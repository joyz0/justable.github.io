(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{325:function(t,a,s){"use strict";s.r(a);var e=s(28),o=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"需求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#需求"}},[t._v("#")]),t._v(" 需求")]),t._v(" "),s("p",[t._v("当前台调用需要登录状态的接口时，若此时未登录，要么直接重定向到登陆界面，但是这样在登录后很难回到之前的页面，且交互不友好；另一种是直接在当前页弹登录框，淘宝就是如此，登录后刷新当前页即可。我选择第二种方案。")]),t._v(" "),s("h3",{attrs:{id:"未登录时弹登录框"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#未登录时弹登录框"}},[t._v("#")]),t._v(" 未登录时弹登录框")]),t._v(" "),s("p",[t._v("场景是一个 react 项目，请求用了 axios 库。")]),t._v(" "),s("ol",[s("li",[t._v("在每个接口的回调函数中判断后台返回的标识，然后选择是否弹框，但是如此逻辑散落在各个请求的回调中，难以维护。")]),t._v(" "),s("li",[t._v("在 axios 的拦截 response 中判断，但是 axios 的拦截配置在一个单独的 js 文件中，并非 react 组件，如何操控弹框？\n"),s("ol",[s("li",[t._v("使用 redux 通信，将登录框组件在 layout.jsx 中引入，并依赖 redux 库中的是否可见变量。")]),t._v(" "),s("li",[t._v("将 axios 封装成不可见的虚拟组件，登录框组件集成在 axios 组件中，然后 connect 到局部组件中以供调用，但如此非常麻烦，且会有很多 connect。")]),t._v(" "),s("li",[t._v("将 axios 封装成不可见的虚拟组件，登录框组件集成在 axios 组件中，在 layout 中引入，依靠 context 传递给子组件。")])])])]),t._v(" "),s("p",[t._v("上述方案都是我依情景所想，感觉并非最优解，倾向于 2.1。"),s("br"),t._v("\n引申出一个额外的感悟，在代码层面不管如何优化，最终都是把一段逻辑抽离到一个公共文件或统一入口中维护，实际效果是，这一个公共文件或统一入口依然需要被每个业务文件所引入，新增一个业务文件时，依然需要重新引入那个公共文件。"),s("br"),t._v("\n我觉得把这些公共逻辑放到编译层，才能真正的解放对公共逻辑维护与引入，比如 next.js 的路由，只需在 page 文件夹中放置页面文件即可。当然这扯远了，未登录是弹登录框并不需要如此大动干戈。")])])}),[],!1,null,null,null);a.default=o.exports}}]);