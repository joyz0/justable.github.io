(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{238:function(e,t,s){e.exports=s.p+"assets/img/docker_layers.561084df.png"},307:function(e,t,s){"use strict";s.r(t);var n=s(28),r=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"概述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),n("p",[e._v("container 就相当于一个正在运行的进程，它运行在独立的文件系统中，独立于主机和其他 containers。")]),e._v(" "),n("p",[e._v("Dockerfile 中描述了如何为 container 组装一个私人的文件系统。")]),e._v(" "),n("p",[e._v("image 就像是创建 container 的模版，可以通过运行它创建一个新的 container，或者配合 Dockerfile 组装成一个新的 image。")]),e._v(" "),n("h2",{attrs:{id:"分层结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#分层结构"}},[e._v("#")]),e._v(" 分层结构")]),e._v(" "),n("p",[e._v("一个被运行的 image 由多个可读的镜像层组成，通过 Dockerfile 中的 FROM 关键字连接，当启动一个容器时，相当于在 image 上再加了一层可写的容器层。")]),e._v(" "),n("p",[n("img",{attrs:{src:s(238),alt:""}})]),e._v(" "),n("h2",{attrs:{id:"容器的数据管控"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#容器的数据管控"}},[e._v("#")]),e._v(" 容器的数据管控")]),e._v(" "),n("p",[e._v("在容器中的任何写入操作，都只会记录在容器层，这导致所有修改会随容器的销毁而丢失，这就涉及到如何管理容器层的数据--持久化和数据共享，"),n("a",{attrs:{href:"https://docs.docker.com/storage/",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方文档"),n("OutboundLink")],1),e._v("中主要列举了 volumes 和 bind mounts 两种方案。")]),e._v(" "),n("p",[e._v("volumes 方案中，数据卷 volume 是独立于容器层的存储机制，它是一个持久存在的可以被不同容器共享的且被 docker 管控的中间存储点（linux 情况下在"),n("code",[e._v("/var/lib/docker/volumes")]),e._v("中），可以通过 docker cli 命令管理它，这是官方推荐的方案。")]),e._v(" "),n("p",[e._v("bind mounts 方案和 volumes 方案不同地方在于，它挂载的存储点是自定义的宿主机的绝对路径，无法通过 docker cli 命令管理它。")]),e._v(" "),n("h2",{attrs:{id:"docker-的网络通讯模型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#docker-的网络通讯模型"}},[e._v("#")]),e._v(" Docker 的网络通讯模型")]),e._v(" "),n("p",[e._v("什么是 bridge 模式，host 模式，"),n("code",[e._v("-p")]),e._v("后发生了什么，什么是网桥\n以后再补，涉及太多计算机网络的知识点，现在 hold 不住")]),e._v(" "),n("p",[e._v("https://zhuanlan.zhihu.com/p/128617017\nhttps://zhuanlan.zhihu.com/p/104503057\nhttps://zhuanlan.zhihu.com/p/85088047\nhttps://zhuanlan.zhihu.com/p/59538531")]),e._v(" "),n("h2",{attrs:{id:"docker-compose"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#docker-compose"}},[e._v("#")]),e._v(" Docker Compose")]),e._v(" "),n("p",[e._v("Docker Compose 是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。使用 compose，我们可以通过 YAML 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。")]),e._v(" "),n("h2",{attrs:{id:"dockerfile-的使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile-的使用"}},[e._v("#")]),e._v(" Dockerfile 的使用")]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://docs.docker.com/engine/reference/builder/",target:"_blank",rel:"noopener noreferrer"}},[e._v("所有指令"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://docs.docker.com/develop/develop-images/dockerfile_best-practices/",target:"_blank",rel:"noopener noreferrer"}},[e._v("最佳实践"),n("OutboundLink")],1)])]),e._v(" "),n("div",{staticClass:"language-sh line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 指定一个镜像作为父镜像")]),e._v("\nFROM node:current-slim\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 设置一个工作路径，注意这里的路径不是真实主机中的路径，而是被隔离的虚拟文件系统")]),e._v("\nWORKDIR /usr/src/app\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 把真实主机当前路径下的package.json拷贝到虚拟文件系统的当前路径WORKDIR下")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 不在这COPY . .是为了更好的利用缓存")]),e._v("\nCOPY package.json "),n("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v(".")]),e._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 在虚拟文件系统中执行命令")]),e._v("\nRUN "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("npm")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("install")]),e._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 告诉Docker启动容器时监听指定的端口号")]),e._v("\nEXPOSE "),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("8080")]),e._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 在容器中运行指定的命令")]),e._v("\nCMD "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"npm"')]),e._v(", "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"start"')]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 把真实主机中app的剩余文件拷贝到虚拟文件系统中")]),e._v("\nCOPY "),n("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v(".")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v(".")]),e._v("\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br"),n("span",{staticClass:"line-number"},[e._v("18")]),n("br"),n("span",{staticClass:"line-number"},[e._v("19")]),n("br"),n("span",{staticClass:"line-number"},[e._v("20")]),n("br"),n("span",{staticClass:"line-number"},[e._v("21")]),n("br")])]),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),n("p",[e._v("注意单独先"),n("code",[e._v("COPY package.json .")]),e._v("是为了更好的利用 docker 缓存，只有当 package.json 发生改变时才会重新安装依赖，如果直接在这"),n("code",[e._v("COPY . .")]),e._v("，那么这个项目的任何文件更改都会重新安装依赖，参考"),n("a",{attrs:{href:"http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/",target:"_blank",rel:"noopener noreferrer"}},[e._v("这篇文章"),n("OutboundLink")],1),e._v("。")])]),e._v(" "),n("ul",[n("li",[e._v("ADD")])]),e._v(" "),n("p",[e._v("功能和 COPY 类似，额外支持拷贝远程文件到目标地点")]),e._v(" "),n("ul",[n("li",[e._v("CMD")])]),e._v(" "),n("p",[e._v("当执行"),n("code",[e._v("docker run")]),e._v("时，CMD 中的命令会被执行，如果定义了 ENTRYPOINT，则会作为参数附加到 ENTRYPOINT 命令后面。")]),e._v(" "),n("p",[e._v("如果"),n("code",[e._v("docker run [custom args]")]),e._v("有未被消耗的参数，则会覆盖 CMD。")]),e._v(" "),n("ul",[n("li",[e._v("ENTRYPOINT")])]),e._v(" "),n("p",[e._v("ENTRYPOINT 中的命令会在 "),n("code",[e._v("docker run")]),e._v(" 时执行，如果"),n("code",[e._v("docker run [custom args]")]),e._v("有未被消耗的参数，则会作为参数附加到 ENTRYPOINT 命令后面。")]),e._v(" "),n("p",[n("code",[e._v("docker run --entrypoint")]),e._v("可以覆盖 ENTRYPOINT。")]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),n("p",[e._v("ENTRYPOINT 和 CMD 的区别就是"),n("code",[e._v("docker run [custom args]")]),e._v("中未被消耗的参数会附加到 ENTRYPOINT，覆盖 CMD。")])]),e._v(" "),n("p",[e._v("-- VOLUME")]),e._v(" "),n("p",[e._v("不同于"),n("code",[e._v("-v A:B")]),e._v("命令。Dockerfile 的 VOLUME 指令只能创建匿名 volume，不能与宿主机目录进行挂载（为了镜像的可迁移性），相当于"),n("code",[e._v("-v B")]),e._v("。")]),e._v(" "),n("h2",{attrs:{id:"常用命令"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#常用命令"}},[e._v("#")]),e._v(" 常用命令")]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://docs.docker.com/engine/reference/commandline/docker/",target:"_blank",rel:"noopener noreferrer"}},[e._v("所有命令"),n("OutboundLink")],1)])]),e._v(" "),n("ul",[n("li",[e._v("docker pull nginx:latest")])]),e._v(" "),n("p",[e._v("拉取镜像，默认 latest 版本")]),e._v(" "),n("ul",[n("li",[e._v("docker build --tag bulletinboard:1.0 .")])]),e._v(" "),n("p",[e._v("会根据同级目录的 Dockerfile 文件创建新的 image")]),e._v(" "),n("ul",[n("li",[e._v("docker image ls OR docker images")])]),e._v(" "),n("p",[e._v("显示本地安装的 image")]),e._v(" "),n("ul",[n("li",[e._v("docker image rm nginx")])]),e._v(" "),n("p",[e._v("删除本地镜像")]),e._v(" "),n("ul",[n("li",[e._v("docker run -p 8000:8080 -d --name test nginx:latest")])]),e._v(" "),n("p",[e._v("启动一个 container（等价于 docker create & docker start），如果本机没有该镜像，则会自动拉取远程镜像到本地。")]),e._v(" "),n("p",[e._v("增加"),n("code",[e._v("-p")]),e._v("表示把主机的 8000 端口转发到 container 的 8080 端口。")]),e._v(" "),n("p",[e._v("增加"),n("code",[e._v("-d")]),e._v("告诉 docker 在后台运行此 container。")]),e._v(" "),n("p",[e._v("增加"),n("code",[e._v("--name")]),e._v("为 container 定义了别名 test。")]),e._v(" "),n("p",[e._v("增加 "),n("code",[e._v("--it")]),e._v("（i 和 t 通常一同使用）可以直接进入 container 内部，相当于"),n("code",[e._v("docker exec")]),e._v("的效果，注意"),n("code",[e._v("-t")]),e._v("后面要加"),n("code",[e._v("/bin/bash")]),e._v("，比如"),n("code",[e._v("docker run -it --name test nginx /bin/bash")]),e._v("。")]),e._v(" "),n("p",[e._v("增加 "),n("code",[e._v("-v")]),e._v(" 可以挂载 volume 到容器内的指定目录，实现数据共享和持久化，格式为"),n("code",[e._v("-v A:B[:option]")]),e._v("，B 是容器内的绝对路径，option 可以是 ro，设置容器那一端为只读模式，A 则有三种形式：")]),e._v(" "),n("ol",[n("li",[e._v("volume 名称")]),e._v(" "),n("li",[e._v("省略，即匿名模式，docker 会随机生成名称")]),e._v(" "),n("li",[e._v("宿主机的绝对路径（"),n("a",{attrs:{href:"https://docs.docker.com/storage/bind-mounts/",target:"_blank",rel:"noopener noreferrer"}},[e._v("bind-mounts 模式"),n("OutboundLink")],1),e._v("）")])]),e._v(" "),n("p",[e._v("增加 "),n("code",[e._v("--mount")]),e._v(" 作用和 "),n("code",[e._v("-v")]),e._v(" 类似，参考"),n("a",{attrs:{href:"https://docs.docker.com/storage/bind-mounts/#choose-the--v-or---mount-flag",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("p",[e._v("增加 "),n("code",[e._v("--volumes-from")]),e._v(" 可以为当前容器挂载另一个容器的 volume，即共用一个 volume，实现数据互通共享。")]),e._v(" "),n("p",[e._v("增加 "),n("code",[e._v("--rm")]),e._v(" 创建临时容器，会在容器退出时自动删除，同时还会自动删除匿名 volume。")]),e._v(" "),n("ul",[n("li",[e._v("docker ps")])]),e._v(" "),n("p",[e._v("显示正在启动的 container")]),e._v(" "),n("ul",[n("li",[e._v("docker stop bb")])]),e._v(" "),n("p",[e._v("停止运行某个 container")]),e._v(" "),n("ul",[n("li",[e._v("docker rm --force bb")])]),e._v(" "),n("p",[e._v("强制删除某个 container，如果 container 正在运行会先停止它并删除，如果要删除一个已被停止的 container，则不需要"),n("code",[e._v("--force")])]),e._v(" "),n("ul",[n("li",[e._v("docker exec -it "),n("code",[e._v("<container id/name>")]),e._v(" /bin/bash")])]),e._v(" "),n("p",[e._v("进入容器内部，和 docker attach 的区别是后者退出时会停止容器")]),e._v(" "),n("ul",[n("li",[e._v("docker volume create volumeName")])]),e._v(" "),n("p",[e._v("创建 volume，linux 系统下所有 docker 管控的 volume（除了挂载到宿主机自定义路径的 volume）都在"),n("code",[e._v("/var/lib/docker/volumes")]),e._v("目录下")]),e._v(" "),n("ul",[n("li",[e._v("docker volume inspect volumeName")])]),e._v(" "),n("p",[e._v("查看指定 volume 的信息")]),e._v(" "),n("ul",[n("li",[e._v("docker volume rm volumeName")])]),e._v(" "),n("p",[e._v("清理指定 volume")]),e._v(" "),n("ul",[n("li",[e._v("docker volume prune")])]),e._v(" "),n("p",[e._v("清理所有没有被容器使用到的 volume")])])}),[],!1,null,null,null);t.default=r.exports}}]);