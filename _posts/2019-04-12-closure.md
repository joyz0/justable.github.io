---
title:  "Closure"
date:   2019-04-12 9:54:00
categories: [blog]
tags: [javascript]
---

- 闭包：是代码块和创建该代码块的上下文中数据的结合
- 自由变量：是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量
- 理论上所有函数都可以称为闭包，因为所有函数都是在全局scope下的子作用域
- 实践角度：以下函数才算是闭包：
1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
2. 在代码中引用了自由变量

例子一：
```js
function createCount() {
  var n = 0
  var inner = function (){
    console.log(++n)
  }
  inner()
}
createCount()
```
当在函数内部定义了另一个函数，此时就创建了一个closure（以前一直错误的认为只有返回内部函数，并被外部调用时才产生closure）。  
例子二：
```js
function createCount() {
  var n = 0
  var inner = function (){
    console.log(++n)
  }
  return inner
}
var count = createCount()
count() // 1
count() // 2
```
count变量内部指针指向inner函数，同时隐性指向了一个closure（可以看作一个包含外部函数变量的对象）。  
例子三：
```js
var log, increase, set
function setup() {
  var num = 42
  log = function() { console.log(num) }
  increase = function() { num++ }
  set = function(x) { num = x }
}
setup()
increase()
log() // 43
set(5)
log() // 5
var oldLog = log
setup()
log() // 42
oldLog() // 5
```
赋值给全局变量，此时三个全局变量指向不同的函数但隐性指向同一个closure。  
例子四：
```js
function buildList(list) {
  var result = [];
  for (var i = 0; i < list.length; i++) {
    var item = 'item' + i;
    result.push( function() {console.log(item + ' ' + list[i])} );
  }
  return result;
}
function testList() {
  var fnlist = buildList([1,2,3]);
  // Using j only to help prevent confusion -- could use i.
  for (var j = 0; j < fnlist.length; j++) {
    fnlist[j]();
  }
}
testList() //logs "item2 undefined" 3 times
```
如果var i = 0改为let i = 0，则结果logs "item1/item2/item3 undefined"，这是因为var声明变量是函数作用域，而let声明变量是语句块作用域，相当于
```js
function buildList(list) {
  var i = 0
  var result = [];
  for (; i < list.length; i++) {
    var item = 'item' + i;
    result.push( function() {console.log(item + ' ' + list[i])} );
  }
  return result;
}
function buildList(list) {
  var result = [];
  for (; i < list.length; i++) {
    let i = 0
    var item = 'item' + i;
    result.push( function() {console.log(item + ' ' + list[i])} );
  }
  return result;
}
```
例子五：
```js
function count() {
  var n = 0
  var inner = new Function('console.log(++n)')
  inner()
}
count() // Uncaught ReferenceError: n is not defined
```
new Function不会创建closure
```js
var n = 0
var outter = new Function('console.log(++n)')
outter() // 1
```
例子六：
```js
function count (){
  var n = 0
  eval('function inner(){ console.log(n) }')
  inner()
}
count() // 0
```
eval会创建closure。  
例子七：
```js
var word = 'World';
function sayHello() {
  console.log('Hello ' + word);
}
var sayHola = new Function('var inner = ' + sayHello.toString().replace(/Hello/,'Hola') + ';inner();')
// 等价于
var sayHola2 = function () {
  var inner = function sayHello() {
    console.log('Hello ' + word);
  }
  inner()
}
sayHola()
sayHola2()
```
当sayHello函数在全局作用域中时，动态创建函数可行。
```js
function outter(word) {
  function sayHello() {
    console.log('Hello ' + word);
  }
  var sayHola = new Function('var inner = ' + sayHello.toString().replace(/Hello/,'Hola') + ';inner();')
  // 等价于
  var sayHola2 = function (){
    var inner = function sayHello() {
      console.log('Hola ' + word);
    }
    inner()
  }
  sayHola() // Uncaught ReferenceError: word is not defined
  sayHola2() // Hello World
}
outter('World')
```
当sayHello函数是closure时，动态创建函数不可行。

### Reference
[https://stackoverflow.com/questions/111102/how-do-javascript-closures-work](1)

[1]: https://stackoverflow.com/questions/111102/how-do-javascript-closures-work
