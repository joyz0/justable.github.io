---
title: "Browser"
date: 2019-05-22 16:17:00
categories: [blog]
tags: [Browser]
---

### 名词索引

- 位图？？？：这里特指浏览器中的位图，一个二维数组，每一项对应存放图片中的像素颜色，达到描述一块图片的效果。
- 纹理？？？：纹理是 GPU 专用的，需要有固定格式且有大小限制，好比 GPU 中的位图，存储在 GPU video RAM 中。
- Rasterize(光栅化)？？？：这里特指浏览器中的光栅化，浏览器将位图光栅化为纹理传给 GPU，早年的 Full-screen 基本都进化到了现在的 Tile-Based。其他描述“把物体的数学描述以及与物体相关的颜色信息转换为屏幕上的像素”。
- draw：GPU 最终把纹理显示到屏幕上

### 浏览器中的进程

- Renderer 进程：每个 tab 页一个，包含 3 个线程
  1. Compositor Thread？？？
  2. Main Thread
  3. Compositor Tile Worker(s)：由 Compositor Thread 创建的，专门用来处理 tile 的光栅化
- GPU 进程：整个浏览器共用一个，主要是负责把 Renderer 进程中绘制好的 tile 位图作为纹理上传至 GPU，并调用 GPU 的相关方法把纹理 draw 到屏幕上。

### task 和 microtask

- task（macrotask）：主代码块，setTimeout，setInterval 等（可以看到，事件队列中的每一个事件都是一个 macrotask）
- microtask：Promise，process.nextTick 等

### Event loop

[8]: https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model

先举个例子：

```js
(function main() {
  setTimeout(() => console.log(9), 0);
  console.log(1);
  new Promise(function exec(resolve) {
    console.log(2);
    resolve();
    Promise.resolve().then(() => console.log(5));
    console.log(3);
  }).then(() => {
    console.log(6);
    Promise.resolve().then(() => console.log(8));
    console.log(7);
  });
  console.log(4);
  // output：1，2，3，4，5，6，7，8，9
})();
```

[html5 官方规范](8)

1. 从多个 task 队列中里选出一个 task 队列（浏览器为了区分不同 task 的优先级，所以时常有多个 task 队列），从这个 task 队列中取出最老的那个 task，执行他，然后把他从队列中去除。
2. perform a microtask checkpoint，这个步骤其实包含了多个子步骤，只要 microtask queue 不空，这一步会一直从 microtask queue 中取出 microtask，执行之。如果 microtask 执行过程中又添加了 microtask，那么仍然会执行新添加的 microtask。
3. Update the rendering（更新渲染），
4. run the resize steps
5. run【the scroll steps（是个队列，存放期间发生过 scroll 的 target）】
6. 更新、渲染用户界面

### 浏览器帧

⚠️ 一帧中的 js 执行阶段可能对应多次 event loop。

理想的帧数是 60FPS，也就是 1s60 帧，16.67ms 一帧。每一帧的执行内容如下图所示：
![](/images/2019-05-22-browser/5.png)
![](/images/2019-05-22-browser/6.png)
从上图可以发现，只要执行足够快，requestIdleCallback 会无限接近 16.67ms。

### 浏览器渲染原理

当浏览器初始接收到 html 文件：

1. 解析 html 生成 dom 树（会被 script 阻塞）
2. 解析 css 生成 cssom 树（会被 script 阻塞）
3. 合成 dom 树和 cssom 树生成 render 树（RenderObject 树，与 dom 树一一对应）
4. 根据 render 树进行 layout（位置）
5. 根据 render 树进行 paint（不涉及节点位置变动）
6. GPU 进行 composite

或之后的 eventloop 中 js 修改了 dom/style：

1. 执行 js
2. 计算 style 更新 RenderObject 树
3. layout
4. paint
5. GPU 进行 composite

![](/images/2019-05-22-browser/7.png)
![](/images/2019-05-22-browser/9.jpg)

⚠️ RenderLayer：在生成/更新 RenderObject 树的同时会生成/更新 RenderLayer，来解决网页绘制的层次顺序问题（前节点可能显示在后节点之上），不提升为 RenderLayer 的 RenderObject 归属于其父级中离它最近的那个 RenderLayer，根元素 HTML 自己要先提升为 RenderLayer。

```
html->RenderLayer0
  div1->RenderLayer1
  div2->RenderLayer2
    div2_1->RenderLayer2
    div2_2->RenderLayer3
    div2_3->RenderLayer2
  div3->RenderLayer1
```

![](/images/2019-05-22-browser/8.jpg)

⚠️ GraphicsLayer：解决了层级问题还是不够的，面对 animation、video、canvas、3d 的 css 等东西时页面显示会经常变动，如果每次变动都重绘整个位图，性能开销会非常大，于是浏览器把这些隔离到 GraphicsLayer（合成层 CompositingLayer） 和 GraphicsContext。不提升为 GraphicsLayer 的 RenderLayer 归属于其父级中离它最近的那个 GraphicsLayer，根元素 HTML 自己要先提升为 Graphics Layer。

> 总结来讲，RenderLayer 解决了位图的层级问题，GraphicsLayer 把动画之类的。通常的 RenderLayer 都是由 CPU 处理，GraphicsLayer 会交付 GPU 处理，这就是常说的渲染硬件加速。

常见的提升为 GraphicsLayer 的情况（不包括全部）：

1. 3D 或透视变换(perspective、transform) CSS 属性
2. 使用加速视频解码的 元素
3. 拥有 3D (WebGL) 上下文或加速的 2D 上下文的 元素
4. 混合插件(如 Flash)
5. 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）
6. will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）
7. 拥有加速 CSS 过滤器的元素
8. 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)
9. 发生重叠的层时，处于下面的层若为 GraphicsLayer，则上面的层也会隐式的提升为 GraphicsLayer

还可以如下手动指定生成 GraphicsLayer：

```css
// 新型浏览器
#target {
  will-change: transform;
}
// 不支持will-change的浏览器
#target {
  transform: translateZ(0);
}
```

⚠️ GraphicsLayer 在处理动画有很好的优势，但我们要注意的是它会占用内存，如果我们手动为不经常变动的元素肆意添加 will-change，则会导致内存的浪费，反而桎梏了最终表现的性能。并且对于一次性或不频繁的动画，比如一个按钮点击后触发一个动画效果的场景，最好在 button 的 hover 事件中动态的为目标添加 will-change，在 animationEnd 事件中再把 will-change 去除，释放内存。

[1]: https://juejin.im/entry/590801780ce46300617c89b8
[2]: https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
[3]: https://fed.taobao.org/blog/2016/04/25/performance-composite/
[4]: https://www.cnblogs.com/feng9exe/p/10907959.html
[5]: https://juejin.im/entry/59dc9aedf265da43200232f9
[6]: https://segmentfault.com/a/1190000020926189
[7]: http://fouber.github.io/test/layer/
[9]: https://drafts.csswg.org/cssom-view/#run-the-resize-steps

### 时间分片

当某一帧的 JS 中有一段很耗时的同步任务执行时间超过了 16.67ms 最终导致丢帧，时间分片的核心思想就是把一帧当中的耗时任务合理切分到多帧中执行，时间分片通常会使用 requestAnimateFrame 而不是 setTimeout/setInterval，前者会保证在下一帧重绘重排前执行，后者不能保证后续帧连续执行。

### 获取节点宽度问题

clientWidth=width+padding  
offsetWidth=width+padding+border  
scrollWidth=滚动距离

```html
<div
  id="root"
  style="width: 200px; border: 2px solid; /*box-sizing: border-box*/"
>
  <div id="content" style="width: 300px"></div>
</div>
<script>
  var root = document.getElementById("root");
  var clientWidth = root.clientWidth; // content-box：200px border-box：196px
  var offsetWidth = root.offsetWidth; // content-box：204px border-box：200px
  var scrollWidth = root.scrollWidth; // content-box：300px border-box：300px
  // 当出现垂直滚动条时
  if (isMac()) {
    审查元素时的width = `200px`;
  } else {
    审查元素时的width = `183px`;
  }
  // 判断是否处在mac系统中
  function isMac() {
    return /macintosh|mac os x/i.test(navigator.userAgent);
  }
</script>
```

### viewport

viewport 分为 layout viewport，visual viewport，ideal viewport，注意这些都是指独立像素而非物理像素/手机尺寸

- PC 浏览器的 layout viewport 是严格等于浏览器窗口的，移动端浏览器为了能够适应 PC 的网站，把 layout viewport 默认设置为 980px，这样即使页面是按百分比布局，在移动端显示时也不会极度变形，可以通过 document.documentElement.clientWidth 得到 layout viewport 值；
  ![](/images/2019-05-22-browser/1.png)
- visual viewport 决定可视区域大小，可视区域大小可随浏览器缩放而变化，PC 浏览器的 visual viewport 默认等于 layout viewport，可以通过 window.innerWidth 得到 visual viewport 的值；
  ![](/images/2019-05-22-browser/2.png)
- ideal viewport 是每个手机厂商设定的一个理想大小，所谓的理想是指不需要用户缩放和横向滚动条就能正常的查看网站的所有内容，显示的文字的大小是合适（确定仅靠手机浏览器支持而不需要开发者适配？），每个手机厂商设置的不一定一样，比如苹果手机都为 320px。  
  meta 的 viewport 属性中，
- width 是来控制 layout viewport 的，当 width=device-width 时表示把 layout viewport 设置为 ideal viewport，不过在 iphone 和 ipad 上，无论是竖屏还是横屏，宽度都是竖屏时 ideal viewport 的宽度；
  ![](/images/2019-05-22-browser/3.png)
- initial-scale 表示初始的缩放比，它是相对于 ideal viewport 的，所以当 initial-scale=1 时，等价于 width=device-width，公式为 layout viewport = ideal viewport / initial-scale；
  ![](/images/2019-05-22-browser/4.png)
- 当 width 和 initial-scale 同时出现时，浏览器会取较大值作为 layout viewport，并同时解决了兼容问题。
- devicePixelRatio 为设备物理像素和设备独立像素的比例，devicePixelRatio = 物理像素 / 独立像素，CSS 中的 px 代表的就是这独立像素。
- visual viewport = ideal viewport / 当前缩放值
- 当前缩放值 = ideal viewport / visual viewport
- initial-scale 在安卓机中没有默认值，只有设置了 initial-scale 才会生效，在苹果系列中，会自动计算 initial-scale 这个值，以保证 visual viewport 中能完全展现 layout viewport，也就是说不会出现横向滚动条，那么此时的 visual viewport=layout viewport=980，即 initial-scale = 320 / 980
- 当 initial-scale=0 时代表什么？
