(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{246:function(t,s,a){t.exports=a.p+"assets/img/osi.3921f216.png"},247:function(t,s,a){t.exports=a.p+"assets/img/tcp_data.74c4e6eb.jpg"},248:function(t,s,a){t.exports=a.p+"assets/img/tcp_3.72cf28d3.jpg"},249:function(t,s,a){t.exports=a.p+"assets/img/tcp_4.efbeaa50.jpg"},250:function(t,s,a){t.exports=a.p+"assets/img/ssl.eedfd754.png"},332:function(t,s,a){"use strict";a.r(s);var v=a(28),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#引言"}},[t._v("引言")])]),v("li",[v("a",{attrs:{href:"#tcp-的建立"}},[t._v("TCP 的建立")]),v("ul",[v("li",[v("a",{attrs:{href:"#三次握手"}},[t._v("三次握手")])]),v("li",[v("a",{attrs:{href:"#四次挥手"}},[t._v("四次挥手")])]),v("li",[v("a",{attrs:{href:"#faq"}},[t._v("FAQ")])])])]),v("li",[v("a",{attrs:{href:"#http-协议"}},[t._v("HTTP 协议")]),v("ul",[v("li",[v("a",{attrs:{href:"#faq"}},[t._v("FAQ")])])])]),v("li",[v("a",{attrs:{href:"#https-协议"}},[t._v("HTTPS 协议")]),v("ul",[v("li",[v("a",{attrs:{href:"#faq"}},[t._v("FAQ")])])])]),v("li",[v("a",{attrs:{href:"#ssl-认证流程"}},[t._v("SSL 认证流程")]),v("ul",[v("li",[v("a",{attrs:{href:"#faq"}},[t._v("FAQ")])])])])])]),v("p"),t._v(" "),v("h2",{attrs:{id:"引言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[t._v("#")]),t._v(" 引言")]),t._v(" "),v("p",[t._v("计算机网络中，通常有两中分层模型，一种是 OSI 七层模型，另一种是 TCP/IP 四层模型，如下图所示：")]),t._v(" "),v("p",[v("img",{attrs:{src:a(246),alt:""}})]),t._v(" "),v("h2",{attrs:{id:"tcp-的建立"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的建立"}},[t._v("#")]),t._v(" TCP 的建立")]),t._v(" "),v("p",[v("img",{attrs:{src:a(247),alt:""}})]),t._v(" "),v("p",[t._v("TCP 处于传输层，要建立 TCP 连接，需要进行三次握手，断开连接则需要进行四次挥手。")]),t._v(" "),v("h3",{attrs:{id:"三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),v("p",[v("img",{attrs:{src:a(248),alt:""}})]),t._v(" "),v("ol",[v("li",[t._v("第一次：客户端发起请求，报文段的头部中 SYN=1，ACK=0，seq=x，之后客户端进入 SYN-SENT 状态。SYN=1，ACK=0 表示该报文段为连接请求报文，seq=x 为本次 TCP 通信的字节流的初始序号；")]),t._v(" "),v("li",[t._v("第二次：服务端收到后会发送一个应答 SYN=1，ACK=1，seq=y，ack=x+1，之后服务端进入 SYN-RCVD 状态。SYN=1，ACK=1 表示该报文段为连接同意的应答报文，seq=y 表示服务端作为发送者时，发送字节流的初始序号，ack=x+1 表示服务端希望下一个数据报发送序号是从 x+1 开始的字节；")]),t._v(" "),v("li",[t._v("第三次：客户端收到后会发送一个应答 ACK=1，seq=x+1，ack=y+1，之后客户端发送后进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接的建立完成。")])]),t._v(" "),v("h3",{attrs:{id:"四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),v("p",[v("img",{attrs:{src:a(249),alt:""}})]),t._v(" "),v("ol",[v("li",[t._v("第一次：客户端发起请求，报文段的头部中 FIN=1，seq=u，之后客户端进入 FIN-WAIT-1 状态。FIN=1 表示该报文段是一个连接释放请求；")]),t._v(" "),v("li",[t._v("第二次：服务端收到后会发送一个应答 ACK=1，seq=v，ack=u+1，之后服务端进入 CLOSE-WAIT 状态，客户端收到这个应答后进入 FIN-WAIT-2 状态，等待服务端发送连接释放请求；")]),t._v(" "),v("li",[t._v("第三次：此时服务端可能还有数据需要传送，当所有数据传输完毕后，向客户端发送连接释放请求 FIN=1，ACK=1，seq=w，ack=u+1。之后服务端进入 LAST-ACK 状态。")]),t._v(" "),v("li",[t._v("第四次：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态，该状态会持续 2MSL 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态，撤销 TCB。当服务端收到确认应答后，也便进入 CLOSED 状态，撤销 TCB。")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("SYN：synchronous 同步信号。")]),t._v(" "),v("p",[t._v("ISN：Initial sequence number，初始序列号。")]),t._v(" "),v("p",[t._v("ACK：acknowledgement 确认信号。")]),t._v(" "),v("p",[t._v("FIN：finish 结束。")]),t._v(" "),v("p",[t._v("RST：reset 重置。")]),t._v(" "),v("p",[t._v("MSL：是 Maximum Segment Lifetime 的缩写，表示报文在网络中的最大生存时间，通常为 120 秒。")]),t._v(" "),v("p",[t._v("TCB：在两个设备建立连接发送数据之前，双方都必须要先分配内存建立起 TCB 数据块。")])]),t._v(" "),v("h3",{attrs:{id:"faq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#faq"}},[t._v("#")]),t._v(" FAQ")]),t._v(" "),v("ul",[v("li",[t._v("为什么握手需要三次，挥手需要四次？")])]),t._v(" "),v("p",[t._v("第一次握手是必然的，第二次握手让客户端知道了服务端的接受能力和应答能力，第三次握手让服务端知道了客户端的接受能力和应答能力；")]),t._v(" "),v("p",[t._v("挥手时可能还有在传数据，因此不同于握手。第一次挥手：我（客户端）这边想要断连了，如果你（服务端）数据传完了和我说声；第二次挥手：好的，我（服务端）还有点数据要传送；第三次挥手：我（服务端）数据传完了，你（客户端）好关闭了；第四次挥手：好的，我（客户端）关闭了。")]),t._v(" "),v("ul",[v("li",[t._v("为什么第四次挥手时客户端在进入 CLOSED 状态前需要等待 2MSL 时间？")])]),t._v(" "),v("p",[t._v("为了保证服务端能收到客户端的确认应答，若客户端发完确认应答后直接进入 CLOSED 状态，那么如果该应答丢失，服务端等待超时（通常为 0.5 秒、1 秒、2 秒…16 秒，远小于 MSL 时间）后就会重新发送连接释放请求，但此时客户端已经关闭了，不会作出任何响应，因此服务端永远无法正常关闭（其实服务端的超时重传次数达到上限后会自动 reset）。而定为 2MSL 是因为应答的往返最大时间就是 2MSL。")]),t._v(" "),v("h2",{attrs:{id:"http-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-协议"}},[t._v("#")]),t._v(" HTTP 协议")]),t._v(" "),v("p",[t._v("HTTP 是基于 TCP/IP 协议之上的应用层协议，定义了 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求/响应模型，默认端口为 80。")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("http keep-alive 与 tcp keep-alive 不是同一回事。http keep-alive 是为了让 tcp 连接活得更久一点，提高 socket 的效率。而 tcp keep-alive 是 TCP 的一种检测 TCP 连接状况的保鲜机制，当连接很久没有数据报文传输时，tcp 自动发送一个数据为空的报文给对方，如果对方回应了这个报文说明还在线，连接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。")])]),t._v(" "),v("h3",{attrs:{id:"faq-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#faq-2"}},[t._v("#")]),t._v(" FAQ")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("在浏览器地址栏键入 URL，按下回车之后发生了什么？")]),t._v(" "),v("ol",[v("li",[t._v("浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；")]),t._v(" "),v("li",[t._v("据这个 IP，找到对应的服务器，发起 TCP 的三次握手建立 TCP 连接；")]),t._v(" "),v("li",[t._v("浏览器发起 HTTP 请求；")]),t._v(" "),v("li",[t._v("服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；")]),t._v(" "),v("li",[t._v("浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等）；")]),t._v(" "),v("li",[t._v("浏览器对页面进行渲染呈现给用户；")]),t._v(" "),v("li",[t._v("关闭 TCP 连接。")])])]),t._v(" "),v("li",[v("p",[t._v("HTTP/1.x 和 HTTP/2 的区别？")]),t._v(" "),v("ul",[v("li",[t._v("HTTP/1.x 情况下，浏览器和服务端的每个 TCP 连接只允许一个 http 请求，多个请求只能等待前一个请求完成，现代浏览器为了缓节状况通常会打开多个并行的 TCP 连接，通常是 2-8 个，不同浏览器不同。但这终究只是缓解，并没有真正解决问题。")]),t._v(" "),v("li",[t._v("HTTP/2 情况下，浏览器和服务器之间的所有请求都在一个 TCP 连接上进行多路复用，节省了 TCP 连接打开和关闭的开销，这不同于 keep-alive，keep-alive 本质依然只能同时承载一个 http 请求，只不过延长了 TCP 连接的时长，减少了建立 TCP 连接的次数。")])])]),t._v(" "),v("li",[v("p",[t._v("雪碧图在 HTTP/2 中还有必要吗？")]),t._v(" "),v("p",[t._v("在 HTTP/1.x 情况下，通过雪碧图集合可以很好的减少请求数量提升加载速度，这毋庸置疑，但在 HTTP/2，在多路复用的前提下，这还有意义吗？请见"),v("a",{attrs:{href:"https://blog.octo.com/en/http2-arrives-but-sprite-sets-aint-no-dead/",target:"_blank",rel:"noopener noreferrer"}},[t._v("这篇文章"),v("OutboundLink")],1)])])]),t._v(" "),v("h2",{attrs:{id:"https-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https-协议"}},[t._v("#")]),t._v(" HTTPS 协议")]),t._v(" "),v("p",[t._v("HTTPS 协议默认端口为 443，其由 HTTP 和 TLS/SSL 协议组成，其主要目的有三个：")]),t._v(" "),v("ol",[v("li",[t._v("数据保密性：保证数据内容在传输的过程中不会被第三方查看")]),t._v(" "),v("li",[t._v("数据完整性：及时发现被第三方篡改的传输内容")]),t._v(" "),v("li",[t._v("身份校验安全性：保证数据到达用户期望的目的地")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("HTTPS 不防止抓包。它防止两件事情：信息泄漏和信息被篡改。")]),t._v(" "),v("p",[t._v("常说的 HTTPS 四次握手=TCP 三次握手+SSL 认证（很多步骤当作一次握手）")])]),t._v(" "),v("h3",{attrs:{id:"faq-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#faq-3"}},[t._v("#")]),t._v(" FAQ")]),t._v(" "),v("ul",[v("li",[t._v("浏览器 F12 为什么能看到 HTTPS 的明文")])]),t._v(" "),v("p",[t._v("浏览器 F12 之所以能看到 HTTPS 的明文，是因为浏览器处在应用层，HTTP 协议是应用层协议，而 SSL/TLS 是传输层协议，报文经过了传输层，SSL/TLS 已经对报文进行了解密处理，到达应用层已经是明文。")]),t._v(" "),v("h2",{attrs:{id:"ssl-认证流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ssl-认证流程"}},[t._v("#")]),t._v(" SSL 认证流程")]),t._v(" "),v("p",[v("img",{attrs:{src:a(250),alt:""}})]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("先建立 TCP 连接（三次握手），然后进行 SSL 认证。")]),t._v(" "),v("p",[t._v("当第二步客户端发现无效证书时会弹框提醒。")])]),t._v(" "),v("h3",{attrs:{id:"faq-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#faq-4"}},[t._v("#")]),t._v(" FAQ")]),t._v(" "),v("ul",[v("li",[t._v("session ID 是干嘛的？")])]),t._v(" "),v("p",[t._v("经过 SSL 认证后的数据都会通过 premaster secret 加密后传输，而这个 secret 的交换过程需要经历非对称加密算法，由于非对称加密算法 RSA/DSA 非常耗费 CPU 资源，为了解决这个问题，服务端会把客户端生成的 premaster secret 以 session ID 为索引保存起来，并在 TLS 握手阶段传给客户端，下次客户端再次连接是初始这个 session ID，服务端就能找到对应的 premaster secret，节省性能开销。通常 session ID 寿命只有 1 天，如果在此期间没有新的连接，会被删除。")])])}),[],!1,null,null,null);s.default=_.exports}}]);