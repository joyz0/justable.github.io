---
title: "Browser"
date: 2019-05-22 16:17:00
categories: [blog]
tags: [Browser]
---

> 要自行辨别某个环节浏览器是在注册任务还是执行任务，比如 Main Thread 中的 Paint，它其实是把要绘制的步骤以 commands 的形式注册进 SkPicture 的数据结构中，在 Rasterize 时才是真正执行。

### 名词索引

- 位图：一种描述物体及其颜色的数据结构，通常是二维数组。
- 纹理：好比 GPU 中的位图，存储在 GPU video RAM 中，需要有固定格式且有大小限制，GPU 最终就是根据纹理的描述 shipping pixels to screen。
- Rasterize(光栅化)：把物体的数学描述以及与物体相关的颜色信息转换为屏幕上的像素，早年的 Full-screen 基本都进化到了现在的 Tile-Based。
  ![](/images/2019-05-22-browser/16.png)
- draw：GPU 最终把纹理显示到屏幕上。

### Renderer Process 和 GPU Process

![](/images/2019-05-22-browser/6.png)
引用自[博客](https://aerotwist.com/blog/the-anatomy-of-a-frame/)

- Renderer 进程：每个 tab 页一个，包含 以下 3 个线程
  1. Compositor Thread：接收 vsync 信号（OS 通知浏览器开始新一帧的信号）和 用户交互的 I/O 交互信号（比如滚动、点击、鼠标移动等等）。它就像一个浏览器的外交官，负责和 OS 进行交流，很多场景还会亲力亲为，比如「touchmove, scroll, click」，若有绑定回调则快速响应用户并唤醒 Main Thread 处理，若没有则直接响应用户。
  2. Main Thread：负责处理一系列 tasks，浏览器未来的趋势会把这里的一些事务转给 Compositor Thread 处理。
  3. Compositor Tile Worker(s)：由 Compositor Thread 创建的，专门用来处理 tile 的光栅化。
- GPU 进程：整个浏览器共用一个，负责把 layer tiles 和其他渲染相关数据 上传至 GPU，最终由 GPU 进行 compisited。

> ⚠️ 优化性能的一个很好的方式就是移除 Main Thread 中的某一环节。

Compositor Thread 可能在一帧的时间内（一帧的时间会受实际卡顿情况影响）接收到 OS 传来的多次 I/O 交互信号，最终都会节流成一次传递给 Main Thread，所以说「touchmove, scroll, click」这些事件每帧只会触发一次。

上图中红线箭头表示的是 Forced Synchronous Layout or Styles，这会降低性能。我们可以从 Chrome 的 Performance 中分析然后进行优化，这儿是个[分析用例](https://justable.github.io/demos/front/static/forcedsync.html)，接下来解释下分析过程。

先按照例子中的步骤走完，可以看到
![](/images/2019-05-22-browser/10.png)
每帧大约 150ms，这算很卡了。我们把范围缩小到一帧左右可以更清楚的看清 Main Thread 在每帧所执行的内容
![](/images/2019-05-22-browser/11.png)
从调用栈不难猜出 update 就是 requestAnimationFrame 的回调函数，update 下面很多的紫块，带有红色的是 DevTools 在警告页面可能会被强制自动重排，强制自动重排是强制同步布局的另一种说法。  
在下方的 Summary Panel 中标识了发生强制重排的源码位置，点击进入查看
![](/images/2019-05-22-browser/12.png)
Main Thread 遇到代码修改了[会影响元素布局信息的 CSS 样式](https://csstriggers.com/)时，会标记 layout dirty=true，在下一帧再判断若 dirty=true，则执行 Layout 步骤。这个例子每次根据图像的 offsetTop 值计算其 left 属性，而对元素 offsetTop 的访问会立即触发当前帧的重排（当 dirty=true 时，为了确保 offsetTop 的准确性必须在当前帧立即重排），并设置 layout dirty=false。除了访问 offsetTop 会触发立即重排外，还有
![](/images/2019-05-22-browser/13.png)
接下来我们直接在 DevTool 中对代码进行修改，因为是内嵌在 html 中的 script 块所以无法直接编辑，我们复制整个 update 函数到 Console Panel 中，删除使用 offsetTop 的语句并取消注释其下面的语句，然后执行，浏览器就会覆盖原有的 update 函数，更新后的 Performance 图
![](/images/2019-05-22-browser/14.png)
举个更直观的例子：

```js
const container = document.getElementById("container");
// dirty = false
console.log(container.offsetWidth); // 不重排
// dirty = false
console.log(container.offsetWidth); // 不重排
// dirty = false
container.style.width = "100px"; // 下帧再重排
// dirty = true
console.log(container.offsetWidth); // 立即重排
// dirty = false
console.log(container.offsetWidth); // 不重排
// dirty = false
container.style.width = "120px"; // 下帧再重排
// dirty = true
```

### Event loop

[html5 官方规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)

> Event loop 不是浏览器帧，而是 JS 引擎的调度模型。

1. 从多个 task 队列中里选出一个 task 队列（浏览器为了区分不同 task 的优先级，所以时常有多个 task 队列），从这个 task 队列中取出最老的那个 task，执行他，然后把他从队列中去除。
1. perform a microtask checkpoint，这个步骤其实包含了多个子步骤，只要 microtask queue 不空，这一步会一直从 microtask queue 中取出 microtask，执行之。如果 microtask 执行过程中又添加了 microtask，那么仍然会执行新添加的 microtask。
1. Update the rendering（更新渲染），
1. run the resize steps
1. run【the scroll steps（是个队列，存放期间发生过 scroll 的 target）】
1. 更新、渲染用户界面

#### task 和 microtask

举个例子：

```js
(function main() {
  setTimeout(() => console.log(9), 0);
  console.log(1);
  new Promise(function exec(resolve) {
    console.log(2);
    resolve();
    Promise.resolve().then(() => console.log(5));
    console.log(3);
  }).then(() => {
    console.log(6);
    Promise.resolve().then(() => console.log(8));
    console.log(7);
  });
  console.log(4);
  // output：1，2，3，4，5，6，7，8，9
})();
```

- task（macrotask）：主代码块，setTimeout，setInterval 等（可以看到，事件队列中的每一个事件都是一个 macrotask）
- microtask：Promise，process.nextTick 等

### 浏览器帧

⚠️ 一帧中的 js 执行阶段可能对应多次 event loop。

理想的帧数是 60FPS，也就是 1s60 帧，16.67ms 一帧。每一帧的执行内容如下图所示：
![](/images/2019-05-22-browser/5.png)
从上图可以发现，只要执行足够快，requestIdleCallback 会无限接近 16.67ms。

### 浏览器渲染原理

当浏览器初始接收到 html 文件：

1. 解析 html 生成 dom 树（会被 script 阻塞）
2. 解析 css 生成 cssom 树（会被 script 阻塞）
3. 合成 dom 树和 cssom 树生成 render 树（RenderObject 树，与 dom 树一一对应）
4. 根据 render 树进行 layout（位置）
5. 根据 render 树进行 paint（不涉及节点位置变动）
6. GPU 进行 composite

或之后的 eventloop 中 js 修改了 dom/style：

1. 执行 js
2. 计算 style 更新 RenderObject 树
3. layout
4. paint
5. GPU 进行 composite

![](/images/2019-05-22-browser/7.png)
![](/images/2019-05-22-browser/9.jpg)

⚠️ RenderLayer：在生成/更新 RenderObject 树的同时会生成/更新 RenderLayer，来解决网页绘制的层次顺序问题（前节点可能显示在后节点之上），不提升为 RenderLayer 的 RenderObject 归属于其父级中离它最近的那个 RenderLayer，根元素 HTML 自己要先提升为 RenderLayer。

```
html->RenderLayer0
  div1->RenderLayer1
  div2->RenderLayer2
    div2_1->RenderLayer2
    div2_2->RenderLayer3
    div2_3->RenderLayer2
  div3->RenderLayer1
```

![](/images/2019-05-22-browser/8.jpg)

⚠️ GraphicsLayer：解决了层级问题还是不够的，面对 animation、video、canvas、3d 的 css 等东西时页面显示会经常变动，如果每次变动都重绘整个位图，性能开销会非常大，于是浏览器把这些隔离到 GraphicsLayer（合成层 CompositingLayer） 和 GraphicsContext。不提升为 GraphicsLayer 的 RenderLayer 归属于其父级中离它最近的那个 GraphicsLayer，根元素 HTML 自己要先提升为 Graphics Layer。

> 总结来讲，RenderLayer 解决了位图的层级问题，GraphicsLayer 把动画之类的。通常的 RenderLayer 都是由 CPU 处理，GraphicsLayer 会交付 GPU 处理，这就是常说的渲染硬件加速。

常见的提升为 GraphicsLayer 的情况（不包括全部）：

1. 3D 或透视变换(perspective、transform) CSS 属性
2. 使用加速视频解码的 元素
3. 拥有 3D (WebGL) 上下文或加速的 2D 上下文的 元素
4. 混合插件(如 Flash)
5. 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）
6. will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）
7. 拥有加速 CSS 过滤器的元素
8. 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)
9. 发生重叠的层时，处于下面的层若为 GraphicsLayer，则上面的层也会隐式的提升为 GraphicsLayer

还可以如下手动指定生成 GraphicsLayer：

```css
// 新型浏览器
#target {
  will-change: transform;
}
// 不支持will-change的浏览器
#target {
  transform: translateZ(0);
}
```

⚠️ GraphicsLayer 在处理动画有很好的优势，但我们要注意的是它会占用内存，如果我们手动为不经常变动的元素肆意添加 will-change，则会导致内存的浪费，反而桎梏了最终表现的性能。并且对于一次性或不频繁的动画，比如一个按钮点击后触发一个动画效果的场景，最好在 button 的 hover 事件中动态的为目标添加 will-change，在 animationEnd 事件中再把 will-change 去除，释放内存。

[1]: https://juejin.im/entry/590801780ce46300617c89b8
[2]: https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
[3]: https://fed.taobao.org/blog/2016/04/25/performance-composite/
[4]: https://www.cnblogs.com/feng9exe/p/10907959.html
[5]: https://juejin.im/entry/59dc9aedf265da43200232f9
[6]: https://segmentfault.com/a/1190000020926189
[7]: http://fouber.github.io/test/layer/
[9]: https://drafts.csswg.org/cssom-view/#run-the-resize-steps

### 时间分片

> 要分辨屏幕刷新率和浏览器渲染帧，在硬件运行正常情况下为 60FPS，浏览器渲染帧可能因为耗时的同步任务导致渲染帧超过 16.67ms。

时间分片要做的就是把“大块的渲染帧”合理切分成多个“细小的渲染帧”，理想是和屏幕刷新率一致。时间分片通常可以依靠 requestAnimationFrame 和 requestIdleCallback 实现。可以参考[React Faber](https://zhuanlan.zhihu.com/p/37095662)中的时间分片。

### 获取节点宽度问题

clientWidth=width+padding  
offsetWidth=width+padding+border  
scrollWidth=滚动距离

```html
<div
  id="root"
  style="width: 200px; border: 2px solid; /*box-sizing: border-box*/"
>
  <div id="content" style="width: 300px"></div>
</div>
<script>
  var root = document.getElementById("root");
  var clientWidth = root.clientWidth; // content-box：200px border-box：196px
  var offsetWidth = root.offsetWidth; // content-box：204px border-box：200px
  var scrollWidth = root.scrollWidth; // content-box：300px border-box：300px
  // 当出现垂直滚动条时
  if (isMac()) {
    审查元素时的width = `200px`;
  } else {
    审查元素时的width = `183px`;
  }
  // 判断是否处在mac系统中
  function isMac() {
    return /macintosh|mac os x/i.test(navigator.userAgent);
  }
</script>
```

### viewport

viewport 分为 layout viewport，visual viewport，ideal viewport，注意这些都是指独立像素而非物理像素/手机尺寸

- PC 浏览器的 layout viewport 是严格等于浏览器窗口的，移动端浏览器为了能够适应 PC 的网站，把 layout viewport 默认设置为 980px，这样即使页面是按百分比布局，在移动端显示时也不会极度变形，可以通过 document.documentElement.clientWidth 得到 layout viewport 值；
  ![](/images/2019-05-22-browser/1.png)
- visual viewport 决定可视区域大小，可视区域大小可随浏览器缩放而变化，PC 浏览器的 visual viewport 默认等于 layout viewport，可以通过 window.innerWidth 得到 visual viewport 的值；
  ![](/images/2019-05-22-browser/2.png)
- ideal viewport 是每个手机厂商设定的一个理想大小，所谓的理想是指不需要用户缩放和横向滚动条就能正常的查看网站的所有内容，显示的文字的大小是合适（确定仅靠手机浏览器支持而不需要开发者适配？），每个手机厂商设置的不一定一样，比如苹果手机都为 320px。  
  meta 的 viewport 属性中，
- width 是来控制 layout viewport 的，当 width=device-width 时表示把 layout viewport 设置为 ideal viewport，不过在 iphone 和 ipad 上，无论是竖屏还是横屏，宽度都是竖屏时 ideal viewport 的宽度；
  ![](/images/2019-05-22-browser/3.png)
- initial-scale 表示初始的缩放比，它是相对于 ideal viewport 的，所以当 initial-scale=1 时，等价于 width=device-width，公式为 layout viewport = ideal viewport / initial-scale；
  ![](/images/2019-05-22-browser/4.png)
- 当 width 和 initial-scale 同时出现时，浏览器会取较大值作为 layout viewport，并同时解决了兼容问题。
- devicePixelRatio 为设备物理像素和设备独立像素的比例，devicePixelRatio = 物理像素 / 独立像素，CSS 中的 px 代表的就是这独立像素。
- visual viewport = ideal viewport / 当前缩放值
- 当前缩放值 = ideal viewport / visual viewport
- initial-scale 在安卓机中没有默认值，只有设置了 initial-scale 才会生效，在苹果系列中，会自动计算 initial-scale 这个值，以保证 visual viewport 中能完全展现 layout viewport，也就是说不会出现横向滚动条，那么此时的 visual viewport=layout viewport=980，即 initial-scale = 320 / 980
- 当 initial-scale=0 时代表什么？
